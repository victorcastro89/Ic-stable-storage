#![allow(dead_code,unused_imports,unused_variables)]
use criterion::{criterion_group, criterion_main, Criterion, BenchmarkId};
use rand::Rng;
use std::vec;

#[derive(Debug,Default,Clone,Copy)]
struct FreeLocations{
    size: u64,
    offset: u64,
}


fn fill_vector(max:u64) -> Vec<FreeLocations> {
    let mut rng = rand::thread_rng();
    let mut v = Vec::new();
    v.push( FreeLocations{
        size:20,
        offset: 0,
    });

     for i in 1..max {
        
        let last_v = v.pop().unwrap();
        v.push(last_v);
        
        // if i == 500000 {
        //     v.push( FreeLocations{
        //         size: 500 as u64,
        //         offset: 500 as u64,
        //     });
        // }
        // else{
            v.push( FreeLocations{
                size: last_v.size +  rng.gen_range(0..50) as u64,
                offset: rng.gen_range(0..600) as u64,
            });
        // }
           
     }
   v

}

fn find_bn(vec:  Vec<FreeLocations>, size:u64) ->Option<FreeLocations>{
   let p = match vec.binary_search_by(|i| i.size.cmp(&size))  {
        Ok(pos) => {  Some(vec[pos])} 
        Err(_err) => { panic!("Not found bnt");   } 
 
    };
 p
}



fn find_ord_reference(vec:  &Vec<FreeLocations>, size:u64) ->Option<FreeLocations>{

    let a:Vec<FreeLocations>= vec.iter().filter(|x| x.size == size).cloned().collect();
    if a.len()>0  { Some(a[0]) }
    else { panic!("Not found"); }
 
}



fn bench_fibs(c: &mut Criterion) {
    let  vector = fill_vector(1000000);
    let f1 = vector[500000];
  
    let mut group = c.benchmark_group("Find Struct");
    for i in [20u64, 21u64].iter() {
       

        group.bench_function(BenchmarkId::new("Binary tree", i),
        |b | b.iter(|| find_bn(  vector.to_owned(),f1.size)));

        group.bench_function(BenchmarkId::new("Std library Reference", i),
        |b | b.iter(|| find_ord_reference(  &vector.to_owned(),f1.size)));
   
    }
    group.finish();
}

criterion_group!(benches, bench_fibs);
criterion_main!(benches);